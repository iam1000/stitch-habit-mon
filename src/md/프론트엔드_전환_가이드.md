# 프론트엔드 전환 가이드: React to Vue.js

본 문서는 기존 **React 기반의 Stitch 프로젝트**를 **Vue.js (Vue 3, Composition API)** 기반으로 전환하기 위한 상세 가이드입니다.
소스 코드 복제 및 형상 관리(Git) 절차부터, 프레임워크 전환 시의 기술적 검토 사항 및 단계별 실행 방법을 초보자도 쉽게 따라 할 수 있도록 기술합니다.

---

## � 0단계: 듀얼 개발 환경 구성 전략 (Directory & Workspace Strategy)

한 PC에서 기존 React 프로젝트와 새로운 Vue 프로젝트를 동시에 관리하고 개발하기 위한 전략입니다.

### 0-1. 디렉토리 구조 재편
서로 다른 Git 저장소를 연결해야 하므로, 두 프로젝트를 포함하는 상위 폴더를 만들어 관리하는 것이 좋습니다.

```
c:\AI_DEV\
└── stitch_projects/       (상위 루트 폴더 생성)
    ├── stitch-react/      (기존 React 프로젝트 이동)
    │   └── .git/ (기존 저장소 연결)
    └── stitch-vue/        (새로운 Vue 프로젝트)
        └── .git/ (새로운 저장소 연결)
```

### 0-2. VS Code 워크스페이즈 (Multi-root Workspace) 활용
VS Code 하나에서 두 프로젝트를 동시에 열어두고 비교하며 개발할 수 있습니다.

1.  VS Code에서 `stitch-react` 폴더를 엽니다.
2.  `File` > `Add Folder to Workspace...` 메뉴를 선택하여 `stitch-vue` 폴더를 추가합니다.
3.  `File` > `Save Workspace As...`를 선택하여 작업 공간 설정을 저장합니다 (예: `stitch-migration.code-workspace`).
4.  이제 두 프로젝트의 소스를 탭으로 쉽게 오가며 작업할 수 있습니다.

### 0-3. 동시 실행을 위한 포트(Port) 충돌 방지
두 프로젝트를 동시에 `npm run dev`로 실행하려면 포트가 달라야 합니다.

*   **React 프로젝트 (기존)**: 기본 포트 `5173` (또는 `3000`) 유지
*   **Vue 프로젝트 (신규)**: `package.json` 또는 `vite.config.js`에서 포트 변경

**Vue 프로젝트 `vite.config.js` 설정 예시:**
```javascript
export default defineConfig({
  plugins: [vue()],
  server: {
    port: 5174, // React(5173)와 겹치지 않게 설정
  }
})
```

---

## �📅 1단계: 프로젝트 환경 구성 및 소스 관리 (SCM)

기존 React 프로젝트의 자산(이미지, 유틸리티 코드, 스타일 등)을 활용하면서, 새로운 Vue.js 프로젝트로 독립시키는 절차입니다.

### 1-1. 소스 코드 복제 (Local)
기존 프로젝트를 그대로 복사하여 새로운 작업 디렉토리를 생성합니다.

```bash
# 1. 터미널(PowerShell 또는 Git Bash)을 엽니다.
# 2. 상위 폴더로 이동
cd c:\AI_DEV

# 3. 기존 React 프로젝트(stitch)를 새로운 이름(stitch-vue)으로 복제
# (git clone을 사용하지 않고 폴더 자체를 복사하는 것이 더 깔끔할 수 있으나, git 이력을 참고하고 싶다면 clone 사용)
git clone ./stitch ./stitch-vue

# 4. 새로운 프로젝트 폴더로 이동
cd stitch-vue
```

### 1-2. 새로운 Git 저장소 연결
기존 React 프로젝트와의 연결을 끊고, 순수한 Vue.js 프로젝트를 위한 새로운 GitHub 저장소에 연결합니다.

```bash
# 1. 기존 .git 폴더 제거 (기존 커밋 이력 초기화 - 권장)
# (PowerShell)
Remove-Item -Recurse -Force .git
# (Git Bash)
rm -rf .git

# 2. 새로운 Git 초기화
git init

# 3. GitHub에서 'stitch-vue'라는 이름으로 새 레포지토리(Repository) 생성

# 4. 새로운 원격 저장소 연결
git remote add origin <새로운_GITHUB_REPO_URL>
# 예: git remote add origin https://github.com/username/stitch-vue.git

# 5. 초기 상태 커밋 및 푸시
git add .
git commit -m "Initial commit: Migration from React project"
git branch -M main
git push -u origin main
```

---

## 🔍 2단계: 전환 검토 보고서 (Migration Analysis)

React 프로젝트를 Vue.js로 전환하기 위해 시스템 전반의 아키텍처 변화와 라이브러리 교체 전략을 이해해야 합니다.

### 2-1. React vs Vue.js 심층 비교 분석

단순한 문법 차이를 넘어, 두 프레임워크가 추구하는 철학과 기술적 지향점을 이해하면 더 효과적인 전환이 가능합니다.

#### 1. 탄생 배경 및 철학 (Origin & Philosophy)
*   **React (2013, Meta/Facebook)**: "지속해서 데이터가 변화하는 대규모 애플리케이션 구축"을 목표로 탄생했습니다. 철저히 **자바스크립트 중심(Just JavaScript)**의 철학을 가지며, HTML조차 JS 안(JSX)으로 끌어들였습니다.
*   **Vue.js (2014, Evan You)**: Angular의 양방향 데이터 바인딩과 React의 가상 돔 개념을 합쳐 "가장 쉽고 유연한 프레임워크"를 목표로 개인이 만들었습니다. **HTML, CSS, JS의 분리**라는 전통적인 웹 개발 방식을 존중하며 점진적인 적용(Progressive Framework)을 지향합니다.

#### 2. 기술적 특징 (Technical Characteristics)
*   **React (Library)**: 엄밀히 말해 '라이브러리'입니다. 전역 상태, 라우팅 등을 공식적으로 제공하지 않고 커뮤니티(Redux, React Router 등)에 의존합니다. **단방향 데이터 흐름**과 **불변성(Immutability)**을 강조합니다.
*   **Vue.js (Framework)**: '의견이 포함된(Opinionated) 프레임워크'입니다. 라우터(Vue Router), 상태관리(Pinia/Vuex)를 공식적으로 지원하여 생태계가 매우 통일되어 있습니다. **반응형 시스템(Reactivity System)**이 자동으로 의존성을 추적하여 상태 변화를 감지합니다.

#### 3. 사용 강점 및 생산성 (Strengths)
*   **React**: 자유도가 매우 높고 생태계가 방대합니다(React Native 등). JS 숙련도가 높다면 강력한 추상화와 패턴을 만들 수 있습니다.
*   **Vue.js**: **러닝 커브가 낮고 생산성이 즉시 발휘됩니다.** HTML/CSS에 익숙한 퍼블리셔나 디자이너와의 협업이 훨씬 용이합니다. `<template>`, `<script>`, `<style>` 싱글 파일 컴포넌트(SFC) 구조는 코드의 가독성을 크게 높여줍니다.

#### 4. 유지보수의 편의성 (Maintenance)
*   **React**: 개발자마다 코드 스타일(폴더 구조, 상태 관리 라이브러리 선택 등)이 천차만별일 수 있어, 컨벤션 정의가 중요합니다. 잘못 짜여진 React 코드는 `useEffect` 의존성 배열 지옥 등으로 인해 디버깅이 어려울 수 있습니다.
*   **Vue.js**: 프레임워크가 제안하는 가이드라인이 명확하여, **누가 짜더라도 비슷한 구조의 코드**가 나옵니다. 이는 장기적인 유지보수와 팀원 간의 코드 인수인계에 큰 이점으로 작용합니다.

---

**[요약 비교표]**

| 구분 | React (현재) | Vue 3 (변경 목표) | 비고 |
| :--- | :--- | :--- | :--- |
| **기본 언어** | JSX (JavaScript + HTML 혼합) | **SFC (.vue)**<br>(`<template>`, `<script>`, `<style>` 분리) | 구조가 더 명확해짐 |
| **상태 관리** | `useState`, `useEffect` (불변성 관리 필요) | **`ref`, `reactive`** (자동 반응형 감지) | Composition API 사용 |
| **전역 상태** | Context API, Redux 등 다양함 | **Pinia** (공식 권장, 사용 쉬움) | 파편화 없음 |
| **에코시스템** | 방대하지만 파편화됨 (라이브러리 선택 고민) | **공식 라이브러리 중심** (고민 불필요) | 안정적임 |

### 2-2. 주요 라이브러리 교체 및 유지 전략

반드시 교체해야 하는 라이브러리와 그대로 사용할 수 있는 라이브러리를 구분합니다.

*   **❌ 교체 필요 (React 전용)**
    *   `react-router-dom` ➜ **`vue-router`** (필수)
    *   `recharts` ➜ **`vue-chartjs`** (Chart.js 래퍼) 또는 **`apexcharts`** (강력 추천)
    *   `framer-motion` ➜ **Vue `<Transition>`** 또는 **`@vueuse/motion`**
    *   `lucide-react` ➜ **`lucide-vue-next`** (아이콘 이름 동일, 교체 쉬움)

*   **⭕ 유지 가능 (JavaScript 공통)**
    *   `@supabase/supabase-js`: DB 로직 재사용 가능 (`src/supabaseClient.js`)
    *   `exceljs`: 엑셀 다운로드 기능 재사용 가능
    *   `axios` / `fetch`: API 호출 로직 재사용 가능
    *   CSS (`Trace CSS`, `Tailwind CSS`): 스타일 클래스 그대로 사용 가능

---

## 🛠️ 3단계: 기술 스택 전환 (Migration Execution)

이제 복제된 `stitch-vue` 폴더에서 React의 흔적을 지우고 Vue 환경을 구축합니다.

### 3-1. 패키지 정리 (dependency 교체)

`package.json` 파일을 열고 의존성을 교체합니다.

**1. React 관련 패키지 삭제 명령**
```bash
npm uninstall react react-dom react-router-dom lucide-react recharts framer-motion @vitejs/plugin-react eslint-plugin-react-hooks eslint-plugin-react-refresh SimpleBar-react
```

**2. Vue 관련 패키지 설치 명령**
```bash
npm install vue vue-router pinia lucide-vue-next
npm install -D @vitejs/plugin-vue @vue/compiler-sfc
```

### 3-2. 빌드 설정 변경 (vite.config.js)

`vite.config.js`를 수정하여 React 플러그인 대신 Vue 플러그인을 사용하도록 설정합니다.

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue' // 변경됨
import path from 'path'

export default defineConfig({
  plugins: [vue()], // react() -> vue() 로 변경
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

### 3-3. 진입점 파일 변경 (main.jsx ➜ main.js)

1.  `src/main.jsx` 파일을 삭제하고 `src/main.js`를 생성합니다.
2.  `index.html` 파일 내의 스크립트 소스를 `<script type="module" src="/src/main.js"></script>`로 수정합니다.

**src/main.js 예시:**
```javascript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import './index.css' // Tailwind 스타일 유지

const app = createApp(App)

app.use(createPinia()) // 상태 관리
app.use(router)        // 라우터

app.mount('#app')
```

### 3-4. 라우터 설정 (src/router/index.js)

React의 `App.jsx`에 있던 `<Routes>` 내용을 Vue Router 설정으로 옮깁니다.

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import LandingPage from '@/views/LandingPage.vue'
import Dashboard from '@/views/Dashboard.vue'

const routes = [
  { path: '/', component: LandingPage },
  { path: '/login', component: () => import('@/views/Login.vue') },
  { 
    path: '/dashboard', 
    component: Dashboard,
    meta: { requiresAuth: true } // 보호된 라우트
  },
  // ... 나머지 라우트 추가
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

export default router
```

---

## 💻 4단계: 컴포넌트 변환 가이드 (상세)

React 컴포넌트(`JSX`)를 Vue 컴포넌트(`SFC`)로 변환하는 패턴입니다.

### 4-1. 기본 구조 변환

**React (Component.jsx)**
```jsx
import { useState } from 'react';

function Button() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

**Vue (Component.vue)**
```vue
<script setup>
import { ref } from 'vue';

const count = ref(0);
</script>

<template>
  <button @click="count++">
    Count: {{ count }}
  </button>
</template>
```

### 4-2. 주요 문법 대조표

| 패턴 | React | Vue |
| :--- | :--- | :--- |
| **변수 출력** | `{value}` | `{{ value }}` |
| **클래스 바인딩** | `className="box"` | `class="box"` (또는 `:class`) |
| **조건부 렌더링** | `{isShow && <div>...</div>}` | `<div v-if="isShow">...</div>` |
| **리스트 렌더링** | `{list.map(item => <div key={item.id}>...</div>)}` | `<div v-for="item in list" :key="item.id">...</div>` |
| **이벤트 핸들링** | `onClick={handleClick}` | `@click="handleClick"` |
| **Props 전달** | `<Comp title="Hi" />` | `<Comp title="Hi" />` (동일) |
| **자식 요소** | `props.children` | `<slot />` |

---

## 🚧 5단계: 리스크 관리 및 팁

### 5-1. 복잡한 컴포넌트 처리 (Investment.jsx 등)
`Investment.jsx`와 같이 로직이 복잡한 컴포넌트는 한 번에 변환하려 하지 마세요.
1.  **UI 뼈대 잡기**: 기능(함수)을 다 빼고 HTML 구조와 CSS 클래스만 먼저 `<template>`으로 복사합니다.
2.  **데이터 바인딩**: 더미 데이터를 `ref`로 만들어 화면이 제대로 나오는지 확인합니다.
3.  **기능 이식**: `Supabase` 연동 로직 등을 하나씩 `script setup`으로 가져옵니다.

### 5-2. 커스텀 훅 (hooks/useDataMapper.js)
React의 커스텀 훅은 Vue의 **Composables** 패턴으로 아주 쉽게 변환됩니다.
파일명만 `.js`로 유지하고, 내부에서 `useState` 대신 `ref`를 사용하여 객체를 반환하도록 수정하면 됩니다.

### 5-3. 차트 라이브러리 (Chart)
`recharts` 코드는 Vue에서 **절대** 그대로 사용할 수 없습니다.
시간 낭비를 막기 위해 **ApexCharts**의 Vue 버전(`vue3-apexcharts`) 사용을 강력 추천합니다. 옵션 설정이 직관적이고 디자인 커스터마이징이 쉽습니다.

---

이 가이드를 따라 차근차근 진행하시면, 기존 React 프로젝트의 안정적인 구조를 유지하면서 Vue.js의 직관적이고 강력한 기능을 활용하는 새로운 프로젝트로 성공적으로 전환할 수 있습니다.
